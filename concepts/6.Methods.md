# Understanding Declarative Methods in LPS

## Introduction
In LPS, **declarative methods** provide a way to express dynamic values inside test scenarios without writing code.  
They allow test authors to describe *what value is needed* rather than *how to compute it*. This makes scenarios concise, repeatable, and easy to read.

---

## What Are Declarative Methods?
Declarative methods are **inline expressions** prefixed with `$` (e.g., `$random`, `$guid`, `$timestamp`).  
When LPS encounters them in a test definition, it evaluates the method and replaces it with the resulting value.

Examples:
```yaml
url: "https://api.example.com/users?id=$guid()"
```
Here, `$guid()` is declarative: the test definition simply states *“use a GUID here”*. The tool decides how to generate it.

---

## Why Declarative?
- **Simplicity** – No need to embed scripts or write imperative logic.  
- **Reusability** – Values can be stored in variables and referenced later.  
- **Consistency** – Same syntax across URLs, headers, bodies, and variable initializers.  
- **Focus** – Test authors can concentrate on scenario design, not implementation details.

---

## Declarative vs Imperative
- **Imperative approach**: Write custom code (e.g., in JavaScript or Python) to generate values, manage state, and inject them into requests.  
- **Declarative approach (LPS)**: Use predefined methods like `$random`, `$timestamp`, `$jwtclaim`. The “how” is abstracted away; you only declare the intention.

---

## Key Benefits in LPS
1. **Dynamic Data Generation**  
   Methods like `$random`, `$generateemail`, `$counter` ensure every request can have unique, realistic values.  

2. **State Handling Without Code**  
   Counters (`$counter`) and variable storage let you maintain sequence or correlation across multiple requests.  

3. **Interoperability**  
   Methods can be embedded anywhere — URLs, headers, request bodies, or variables — making scenarios flexible.  

4. **Testing at Scale**  
   Declarative expressions are lightweight and evaluated at runtime, enabling high-volume load testing without scripting overhead.

---

## When to Use Them
- Whenever you need **dynamic values** (IDs, timestamps, tokens).  
- To **correlate values** between steps (store with `variable=...` and reuse).  
- To **avoid scripting** while still achieving variability.  
- As a **bridge** between static test definitions and runtime behavior.

---

## Conclusion
Declarative methods are a cornerstone of LPS.  
They turn static YAML configurations into **dynamic, data-driven test scenarios**, empowering testers to model real-world interactions at scale without writing imperative code.  

By understanding the *concept* — declarative means *“describe what you want, not how to do it”* — you can design scenarios that are both powerful and maintainable.